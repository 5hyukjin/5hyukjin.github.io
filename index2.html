<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ìœ ì „ì ìºë¦­í„° ì‹œë®¬ë ˆì´ì…˜</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
    }

    ul {
      display: flex;
      gap: 16px;
      list-style: none;
      padding: 0;
      flex-wrap: wrap;
    }

    li {
      cursor: pointer;
    }

    .selected {
      outline: 3px solid blue;
    }

    .character {
      width: 90px;
      text-align: center;
    }

    .face {
      width: 90px;
      height: 90px;
      position: relative;
      margin-bottom: 6px;
    }

    .eyes {
      position: absolute;
      top: 26px;
      width: 100%;
      text-align: center;
      font-size: 20px;
      line-height: 1;
    }
    
    .mouth {
      position: absolute;
      bottom: 18px;
      width: 100%;
      text-align: center;
      font-size: 18px;
      line-height: 1;
    }

    .panel {
      display: flex;
      gap: 40px;
      margin: 20px 0;
    }
  </style>
</head>
<body>

<h2>ğŸ¯ ëª©í‘œ ìºë¦­í„°</h2>
<div id="targetCharacter"></div>

<h3>í˜„ì¬ ìºë¦­í„° ìœ ì‚¬ë„</h3>
<div id="similarity">0%</div>

<h2>ë‚´ ìºë¦­í„° (ìµœëŒ€ 2ëª… ì„ íƒ)</h2>
<ul id="characterList"></ul>

<h2>í˜„ì¬ êµë°° ìƒíƒœ</h2>
<div class="panel">
  <div>
    <h3>ë¶€ëª¨ A</h3>
    <div id="parentA">ì—†ìŒ</div>
  </div>
  <div>
    <h3>ë¶€ëª¨ B</h3>
    <div id="parentB">ì—†ìŒ</div>
  </div>
</div>

<button id="meetBtn">ìƒˆë¡œìš´ ìºë¦­í„° ë§Œë‚˜ê¸°</button>
<button id="breedBtn">êµë°°í•˜ê¸°</button>

<script>
/**********************
 * ìƒíƒœ
 **********************/
 const TRAITS = {
  numeric: ["color", "roundness"],
  visual: ["bodyShape", "eye", "mouth"]
};
const BODY_SHAPES = [
  "circle",
  "oval",
  "rounded-square",
  "capsule"
];
const EYES = ["â— â—", "â€• â€•", "â–  â– ", "ã…  ã… ", "â—‰ â—‰"];
const MOUTHS = ["â€”", ")", "(", "ã€°", "â—"];

let characters = [];
let selectedIndexes = [];
let partner = null;

/**********************
 * ìœ í‹¸
 **********************/
 function randomTrait(key) {
  switch (key) {
    case "color":
      return Math.floor(Math.random() * 360);

    case "roundness":
      return Math.floor(Math.random() * 100);

    case "eye":
      return randomFrom(EYES);

    case "mouth":
      return randomFrom(MOUTHS);

    case "bodyShape":
      return randomFrom(BODY_SHAPES);
  }
}

function applyBodyShape(el, shape) {
  switch (shape) {
    case "circle":
      el.style.borderRadius = "50%";
      break;
    case "oval":
      el.style.borderRadius = "50%";
      el.style.transform = "scaleY(1.2)";
      break;
    case "rounded-square":
      el.style.borderRadius = "20%";
      break;
    case "capsule":
      el.style.borderRadius = "999px";
      break;
  }
}

function randomFrom(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}


/**********************
 * ìºë¦­í„° ìƒì„±
 **********************/
function createCharacter(traits) {
  return { traits };
}

function generateRandomCharacter() {
  const traits = {};

  TRAITS.numeric.forEach(key => {
    traits[key] = randomTrait(key);
  });

  TRAITS.visual.forEach(key => {
    traits[key] = randomTrait(key);
  });

  return { traits };
}

/**********************
 * ìƒì†
 **********************/
function inheritTrait(a, b, key) {
  const r = Math.random();
  if (r < 0.45) return a;
  if (r < 0.9) return b;
  return randomTrait(key);
}

function createChild(parentA, parentB) {
  const traits = {};

  [...TRAITS.numeric, ...TRAITS.visual].forEach(key => {
    traits[key] = inheritTrait(
      parentA.traits[key],
      parentB.traits[key],
      key
    );
  });

  return { traits };
}
/**********************
 * ì„ íƒ ë¡œì§
 **********************/
function toggleSelect(index) {
  if (selectedIndexes.includes(index)) {
    selectedIndexes = selectedIndexes.filter(i => i !== index);
  } else {
    if (selectedIndexes.length >= 2) return;
    selectedIndexes.push(index);
  }
  render();
}

/**********************
 * UI ìƒì„±
 **********************/
 function renderCharacter(character) {
  const wrap = document.createElement("div");
  wrap.className = "character";

  const face = document.createElement("div");
  face.className = "face";
  face.style.background = `hsl(${character.traits.color}, 70%, 70%)`;
  face.style.borderRadius = `${character.traits.roundness}%`;

  const eyes = document.createElement("div");
  eyes.className = "eyes";
  eyes.textContent = character.traits.eye;

  const mouth = document.createElement("div");
  mouth.className = "mouth";
  mouth.textContent = character.traits.mouth;

  applyBodyShape(face, character.traits.bodyShape);

  face.append(eyes, mouth);
  wrap.appendChild(face);
  return wrap;
}

/**********************
 * ë Œë”ë§
 **********************/
function renderList() {
  const ul = document.getElementById("characterList");
  ul.innerHTML = "";

  characters.forEach(char => {
    const el = renderCharacter(char);
    ul.appendChild(el);
  });
}

function renderParents() {
  const [a, b] = selectedIndexes;

  const pa = document.getElementById("parentA");
  const pb = document.getElementById("parentB");

  pa.innerHTML = "";
  pb.innerHTML = "";

  // ë¶€ëª¨ A
  if (a !== undefined) {
    pa.appendChild(renderCharacter(characters[a]));
  } else {
    pa.textContent = "ì—†ìŒ";
  }

  // ë¶€ëª¨ B
  if (b !== undefined) {
    pb.appendChild(renderCharacter(characters[b]));
  } else if (partner) {
    pb.appendChild(renderCharacter(partner));
  } else {
    pb.textContent = "ì—†ìŒ";
  }
}

function render() {
  renderList();
  renderParents();
  renderTarget();
  renderSimilarity();
}

/**********************
 * ê²Œì„ ë™ì‘
 **********************/
document.getElementById("meetBtn").onclick = () => {
  partner = generateRandomCharacter();
  render();
};

document.getElementById("breedBtn").onclick = () => {
  if (selectedIndexes.length === 0) {
    alert("ë¶€ëª¨ë¥¼ ì„ íƒí•´!");
    return;
  }

  const parentA = characters[selectedIndexes[0]];
  const parentB =
    selectedIndexes[1] !== undefined
      ? characters[selectedIndexes[1]]
      : partner;

  if (!parentB) {
    alert("ë‘ ë²ˆì§¸ ë¶€ëª¨ê°€ í•„ìš”í•´!");
    return;
  }

  const child = createChild(parentA, parentB);
  characters.push(child);

  // ğŸ”¥ ìì‹ ìë™ ì„ íƒ
  selectedIndexes = [characters.length - 1];
  partner = null;

  const similarity = calculateSimilarity(child, targetCharacter);
  if (similarity >= 90) {
    alert(`ğŸ‰ ëª©í‘œ ìºë¦­í„° ë‹¬ì„±! (${similarity}%)`);
  }

  render();  
};

function calculateSimilarity(a, b) {
  let score = 0;
  let total = 0;

  // numeric traits
  TRAITS.numeric.forEach(key => {
    const max = key === "color" ? 360 : 100;
    const diff = Math.abs(a.traits[key] - b.traits[key]);
    score += 1 - diff / max;
    total++;
  });

  // visual traits
  TRAITS.visual.forEach(key => {
    score += a.traits[key] === b.traits[key] ? 1 : 0;
    total++;
  });

  return Math.round((score / total) * 100);
}

let targetCharacter = generateRandomCharacter();

function renderTarget() {
  const el = document.getElementById("targetCharacter");
  el.innerHTML = "";
  el.appendChild(renderCharacter(targetCharacter));
}

function renderSimilarity() {
  const el = document.getElementById("similarity");

  if (selectedIndexes.length === 0) {
    el.textContent = "-";
    return;
  }

  const current = characters[selectedIndexes[0]];
  const value = calculateSimilarity(current, targetCharacter);
  el.textContent = value + "%";

}
/**********************
 * ì´ˆê¸°í™”
 **********************/
characters.push(generateRandomCharacter());
selectedIndexes = [0]; // â­ ì²˜ìŒ ìºë¦­í„° ìë™ ì„ íƒ
render();

</script>

</body>
</html>
