<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ìœ ì „ì ìºë¦­í„° ì‹œë®¬ë ˆì´ì…˜</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
    }

    ul {
      display: flex;
      gap: 16px;
      list-style: none;
      padding: 0;
      flex-wrap: wrap;
    }

    li {
      cursor: pointer;
    }

    .selected {
      outline: 3px solid blue;
    }

    .character {
      width: 90px;
      text-align: center;
    }

    .face {
      width: 90px;
      height: 90px;
      position: relative;
      margin-bottom: 6px;
    }

    .eye {
      position: absolute;
      top: 28px;
      background: #000;
      border-radius: 50%;
    }

    .eye.left { left: 24px; }
    .eye.right { right: 24px; }

    .mouth {
      position: absolute;
      bottom: 22px;
      left: 50%;
      border-bottom: 3px solid #000;
      transform-origin: center;
    }

    .panel {
      display: flex;
      gap: 40px;
      margin: 20px 0;
    }
  </style>
</head>
<body>

<h2>ğŸ¯ ëª©í‘œ ìºë¦­í„°</h2>
<div id="targetCharacter"></div>

<h3>í˜„ì¬ ìºë¦­í„° ìœ ì‚¬ë„</h3>
<div id="similarity">0%</div>

<h2>ë‚´ ìºë¦­í„° (ìµœëŒ€ 2ëª… ì„ íƒ)</h2>
<ul id="characterList"></ul>

<h2>í˜„ì¬ êµë°° ìƒíƒœ</h2>
<div class="panel">
  <div>
    <h3>ë¶€ëª¨ A</h3>
    <div id="parentA">ì—†ìŒ</div>
  </div>
  <div>
    <h3>ë¶€ëª¨ B</h3>
    <div id="parentB">ì—†ìŒ</div>
  </div>
</div>

<button id="meetBtn">ìƒˆë¡œìš´ ìºë¦­í„° ë§Œë‚˜ê¸°</button>
<button id="breedBtn">êµë°°í•˜ê¸°</button>

<script>
/**********************
 * ìƒíƒœ
 **********************/
const TRAITS = ["color", "roundness", "eyeSize", "mouthWidth", "mouthCurve"];

let characters = [];
let selectedIndexes = [];
let partner = null;

/**********************
 * ìœ í‹¸
 **********************/
function randomTrait(key) {
  switch (key) {
    case "color": return Math.floor(Math.random() * 360);
    case "roundness": return Math.floor(Math.random() * 100);
    case "eyeSize": return Math.floor(Math.random() * 14) + 6;
    case "mouthWidth": return Math.floor(Math.random() * 30) + 20;
    case "mouthCurve": return Math.floor(Math.random() * 41) - 20;
  }
}

function generateTraits(fn) {
  return TRAITS.reduce((acc, key) => {
    acc[key] = fn(key);
    return acc;
  }, {});
}

/**********************
 * ìºë¦­í„° ìƒì„±
 **********************/
function createCharacter(traits) {
  return { traits };
}

function generateRandomCharacter() {
  return createCharacter(
    generateTraits((key) => randomTrait(key))
  );
}

/**********************
 * ìƒì†
 **********************/
function inheritTrait(a, b, key) {
  const r = Math.random();
  if (r < 0.45) return a;
  if (r < 0.9) return b;
  return randomTrait(key);
}

function createChild(a, b) {
  return createCharacter(
    generateTraits((key) =>
      inheritTrait(a.traits[key], b.traits[key], key)
    )
  );
}

/**********************
 * ì„ íƒ ë¡œì§
 **********************/
function toggleSelect(index) {
  if (selectedIndexes.includes(index)) {
    selectedIndexes = selectedIndexes.filter(i => i !== index);
  } else {
    if (selectedIndexes.length >= 2) return;
    selectedIndexes.push(index);
  }
  render();
}

/**********************
 * UI ìƒì„±
 **********************/
function createCharacterElement(character) {
  const t = character.traits;
  const wrap = document.createElement("div");
  wrap.className = "character";

  const face = document.createElement("div");
  face.className = "face";
  face.style.background = `hsl(${t.color},70%,70%)`;
  face.style.borderRadius = `${t.roundness}%`;

  const le = document.createElement("div");
  le.className = "eye left";
  le.style.width = le.style.height = `${t.eyeSize}px`;

  const re = document.createElement("div");
  re.className = "eye right";
  re.style.width = re.style.height = `${t.eyeSize}px`;

  const mouth = document.createElement("div");
  mouth.className = "mouth";
  mouth.style.width = `${t.mouthWidth}px`;
  mouth.style.transform =
    `translateX(-50%) rotate(${t.mouthCurve}deg)`;

  face.append(le, re, mouth);
  wrap.appendChild(face);
  return wrap;
}

/**********************
 * ë Œë”ë§
 **********************/
function renderList() {
  const ul = document.getElementById("characterList");
  ul.innerHTML = "";

  characters.forEach((c, i) => {
    const li = document.createElement("li");
    const el = createCharacterElement(c);

    if (selectedIndexes.includes(i)) {
      el.classList.add("selected");
    }

    li.onclick = () => toggleSelect(i);
    li.appendChild(el);
    ul.appendChild(li);
  });
}

function renderParents() {
  const [a, b] = selectedIndexes;

  const pa = document.getElementById("parentA");
  const pb = document.getElementById("parentB");

  pa.innerHTML = "";
  pb.innerHTML = "";

  if (a !== undefined) pa.appendChild(createCharacterElement(characters[a]));
  else pa.textContent = "ì—†ìŒ";

  if (b !== undefined) pb.appendChild(createCharacterElement(characters[b]));
  else if (partner) pb.appendChild(createCharacterElement(partner));
  else pb.textContent = "ì—†ìŒ";
}

function render() {
  renderList();
  renderParents();
  renderTarget();
  renderSimilarity();
}

/**********************
 * ê²Œì„ ë™ì‘
 **********************/
document.getElementById("meetBtn").onclick = () => {
  partner = generateRandomCharacter();
  render();
};

document.getElementById("breedBtn").onclick = () => {
  if (selectedIndexes.length === 0) {
    alert("ë¶€ëª¨ë¥¼ ì„ íƒí•´!");
    return;
  }

  const parentA = characters[selectedIndexes[0]];
  const parentB =
    selectedIndexes[1] !== undefined
      ? characters[selectedIndexes[1]]
      : partner;

  if (!parentB) {
    alert("ë‘ ë²ˆì§¸ ë¶€ëª¨ê°€ í•„ìš”í•´!");
    return;
  }

  const child = createChild(parentA, parentB);
  characters.push(child);

  // ğŸ”¥ ìì‹ ìë™ ì„ íƒ
  selectedIndexes = [characters.length - 1];
  partner = null;

  const similarity = calculateSimilarity(child, targetCharacter);
  if (similarity >= 90) {
    alert(`ğŸ‰ ëª©í‘œ ìºë¦­í„° ë‹¬ì„±! (${similarity}%)`);
  }

  render();  
};

function calculateSimilarity(a, b) {
  let total = 0;
  let score = 0;

  TRAITS.forEach(key => {
    let max;

    switch (key) {
      case "color": max = 360; break;
      case "roundness": max = 100; break;
      case "eyeSize": max = 20; break;
      case "mouthWidth": max = 50; break;
      case "mouthCurve": max = 40; break;
    }

    const diff = Math.abs(a.traits[key] - b.traits[key]);
    score += (1 - diff / max);
    total++;
  });

  return Math.round((score / total) * 100);
}

let targetCharacter = generateRandomCharacter();

function renderTarget() {
  const el = document.getElementById("targetCharacter");
  el.innerHTML = "";
  el.appendChild(createCharacterElement(targetCharacter));
}

function renderSimilarity() {
  const el = document.getElementById("similarity");

  if (selectedIndexes.length === 0) {
    el.textContent = "-";
    return;
  }

  const current = characters[selectedIndexes[0]];
  const value = calculateSimilarity(current, targetCharacter);
  el.textContent = value + "%";

}
/**********************
 * ì´ˆê¸°í™”
 **********************/
characters.push(generateRandomCharacter());
selectedIndexes = [0]; // â­ ì²˜ìŒ ìºë¦­í„° ìë™ ì„ íƒ
render();

</script>

</body>
</html>
