<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ìœ ì „ì ìºë¦­í„° ì‹œë®¬ë ˆì´ì…˜</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
    }

    ul {
      display: flex;
      gap: 16px;
      list-style: none;
      padding: 0;
      flex-wrap: wrap;
    }

    #characterList li {
      cursor: pointer;
    }

    .selected {
      outline: 3px solid blue;
    }

    .character {
      width: 90px;
      text-align: center;
      position:relative;
    }

    .face {
      width: 90px;
      height: 90px;
      
      margin-bottom: 6px;
    }

    .triangle-shape {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 0;
      border-left: 45px solid transparent;
      border-right: 45px solid transparent;
      border-bottom: 80px solid pink;
    }

    .shape-triangle .eyes {
      position: absolute;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .shape-triangle .mouth {
      position: absolute;
      top: 55px;
      left: 50%;
      transform: translateX(-50%);
    }

    .face-content {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .eyes {
      position: absolute;
      top: 26px;
      width: 100%;
      text-align: center;
      font-size: 20px;
      line-height: 1;
    }
    
    .mouth {
      position: absolute;
      bottom: 18px;
      width: 100%;
      text-align: center;
      font-size: 18px;
      line-height: 1;
    }

    .panel {
      display: flex;
      gap: 40px;
      margin: 20px 0;
    }
    
    .dex {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 16px;
      list-style: none;
      padding: 0;
    }
    
    .dex li {
      text-align: center;
      font-size: 12px;
    }
    
    /* ë¯¸ë°œê²¬ ì¹´ë“œ */
    .dex .unknown {
      width: 90px;
      height: 90px;
      border-radius: 12px;
      background: repeating-linear-gradient(
        45deg,
        #ddd,
        #ddd 10px,
        #ccc 10px,
        #ccc 20px
      );
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
      font-weight: bold;
    }
    
    /* í¬ê·€ë„ ë¶„ìœ„ê¸° (ë‚˜ì¤‘ í™•ì¥ìš©) */
    .dex .rare { outline: 2px solid #4aa3ff; }
    .dex .epic { outline: 2px solid #b44cff; }
    .dex .legendary { outline: 2px solid gold; }
  </style>
</head>
<body>

<h2>ğŸ¯ ëª©í‘œ ìºë¦­í„°</h2>
<div id="targetCharacter"></div>

<h3>í˜„ì¬ ìºë¦­í„° ìœ ì‚¬ë„</h3>
<div id="similarity">0%</div>

<h2>ë‚´ ìºë¦­í„° (ìµœëŒ€ 2ëª… ì„ íƒ)</h2>
<ul id="characterList"></ul>

<h2>í˜„ì¬ êµë°° ìƒíƒœ</h2>
<div class="panel">
  <div>
    <h3>ë¶€ëª¨ A</h3>
    <div id="parentA">ì—†ìŒ</div>
  </div>
  <div>
    <h3>ë¶€ëª¨ B</h3>
    <div id="parentB">ì—†ìŒ</div>
  </div>
</div>

<button id="meetBtn">ìƒˆë¡œìš´ ìºë¦­í„° ë§Œë‚˜ê¸°</button>
<button id="breedBtn">êµë°°í•˜ê¸°</button>

<h2>ğŸ“˜ ìºë¦­í„° ë„ê°</h2>
<ul id="dexList" class="dex"></ul>

<script>
/**********************
 * ìƒíƒœ
 **********************/
 const TRAITS = {
  numeric: ["color", "roundness"],
  visual: ["bodyShape", "eye", "mouth"]
};
const BODY_SHAPES = [
  "circle",
  "oval",
  "rounded-square",
  "capsule",
  "triangle",
  "fish"
];
const EYES = ["â— â—", "â€• â€•", "â–  â– ", "ã…  ã… ", "â—‰ â—‰"];
const MOUTHS = ["â€”", ")", "(", "ã€°", "â—"];

let characters = [];
let selectedIndexes = [];
let partner = null;

/**********************
 * ìœ í‹¸
 **********************/
 function randomTrait(key) {
  switch (key) {
    case "color":
      return Math.floor(Math.random() * 360);

    case "roundness":
      return Math.floor(Math.random() * 100);

    case "eye":
      return randomFrom(EYES);

    case "mouth":
      return randomFrom(MOUTHS);

    case "bodyShape":
      return randomFrom(BODY_SHAPES);
  }
}

function applyBodyShape(el, shape, currentColor) {
  el.style.transform = "";
  el.style.borderRadius = "";
  el.style.width = "90px";
  el.style.height = "90px";
  el.style.background = `hsl(${currentColor}, 70%, 70%)`;

  // ì´ˆê¸°í™” (ì¤‘ìš”)
  el.style.clipPath = "";
  el.style.background = "";

  switch (shape) {
    case "circle":
      el.style.background = currentColor;
      el.style.borderRadius = "50%";
      break;

    case "oval":
      el.style.background = currentColor;
      el.style.borderRadius = "50%";
      el.style.transform = "scaleY(1.2)";
      break;

    case "rounded-square":
      el.style.background = currentColor;
      el.style.borderRadius = "20%";
      break;

    case "capsule":
      el.style.background = currentColor;
      el.style.borderRadius = "999px";
      el.style.transform = "scaleX(1.3)";
      break;

    case "triangle":
      el.style.width = "0";
      el.style.height = "0";
      el.style.background = "transparent";
      el.style.borderLeft = "45px solid transparent";
      el.style.borderRight = "45px solid transparent";
      el.style.borderBottom = `80px solid ${currentColor}`;
      break;

    case "fish":
      el.style.background = currentColor;
      el.style.clipPath =
        "polygon(0% 50%, 20% 30%, 50% 20%, 80% 30%, 100% 50%, 80% 70%, 50% 80%, 20% 70%)";
      break;
  }
}

function randomFrom(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}


/**********************
 * ìºë¦­í„° ìƒì„±
 **********************/
function createCharacter(traits) {
  return { traits };
}

function generateRandomCharacter() {
  const traits = {};

  TRAITS.numeric.forEach(key => {
    traits[key] = randomTrait(key);
  });

  TRAITS.visual.forEach(key => {
    traits[key] = randomTrait(key);
  });

  return { traits };
}

/**********************
 * ìƒì†
 **********************/
function inheritTrait(a, b, key) {
  const r = Math.random();
  if (r < 0.45) return a;
  if (r < 0.9) return b;
  return randomTrait(key);
}

function createChild(parentA, parentB) {
  const traits = {};

  [...TRAITS.numeric, ...TRAITS.visual].forEach(key => {
    traits[key] = inheritTrait(
      parentA.traits[key],
      parentB.traits[key],
      key
    );
  });

  return { traits };
}
/**********************
 * ì„ íƒ ë¡œì§
 **********************/
function toggleSelect(index) {
  if (selectedIndexes.includes(index)) {
    selectedIndexes = selectedIndexes.filter(i => i !== index);
  } else {
    if (selectedIndexes.length >= 2) return;
    selectedIndexes.push(index);
  }
  render();
}

/**********************
 * UI ìƒì„±
 **********************/
 function renderCharacter(character) {
  const wrap = document.createElement("div");
  wrap.className = "character";

  const face = document.createElement("div");
  face.className = `face shape-${character.traits.bodyShape}`;
  face.style.background = `hsl(${character.traits.color}, 70%, 70%)`;
  face.style.borderRadius = `${character.traits.roundness}%`;

  const eyes = document.createElement("div");
  eyes.className = "eyes";
  eyes.textContent = character.traits.eye;

  const mouth = document.createElement("div");
  mouth.className = "mouth";
  mouth.textContent = character.traits.mouth;

  const color = `hsl(${character.traits.color}, 70%, 70%)`;
  applyBodyShape(face, character.traits.bodyShape, color);

  face.append(eyes, mouth);
  wrap.appendChild(face);
  return wrap;
}

/**********************
 * ë Œë”ë§
 **********************/
 function renderList() {
  const ul = document.getElementById("characterList");
  ul.innerHTML = "";

  characters.forEach((char, index) => {
    const li = document.createElement("li");

    const el = renderCharacter(char);

    // â­ ì„ íƒëœ ìºë¦­í„° í‘œì‹œ
    if (selectedIndexes.includes(index)) {
      el.classList.add("selected");
    }

    // â­ í´ë¦­ ì‹œ ì„ íƒ í† ê¸€
    li.onclick = () => toggleSelect(index);

    li.appendChild(el);
    ul.appendChild(li);
  });
}

function renderParents() {
  const [a, b] = selectedIndexes;

  const pa = document.getElementById("parentA");
  const pb = document.getElementById("parentB");

  pa.innerHTML = "";
  pb.innerHTML = "";

  // ë¶€ëª¨ A
  if (a !== undefined) {
    pa.appendChild(renderCharacter(characters[a]));
  } else {
    pa.textContent = "ì—†ìŒ";
  }

  // ë¶€ëª¨ B
  if (b !== undefined) {
    pb.appendChild(renderCharacter(characters[b]));
  } else if (partner) {
    pb.appendChild(renderCharacter(partner));
  } else {
    pb.textContent = "ì—†ìŒ";
  }
}

function render() {
  renderList();
  renderParents();
  renderTarget();
  renderSimilarity();
  renderDex();
}

/**********************
 * ë„ê°
 **********************/
 function getDexKey(character) {
  const { bodyShape, eye, mouth } = character.traits;
  return `${bodyShape}_${eye}_${mouth}`;
}

const DEX = [
  {
    id: "circle_basic",
    bodyShape: "circle",
    eye: "â— â—",
    mouth: "â€”",
    rarity: "common",
    discovered: false
  },
  {
    id: "triangle_sad",
    bodyShape: "triangle",
    eye: "ã…  ã… ",
    mouth: "(",
    rarity: "rare",
    discovered: false
  },
]

function registerToDex(character) {
  DEX.forEach(entry => {
    if (
      entry.bodyShape === character.traits.bodyShape &&
      entry.eye === character.traits.eye &&
      entry.mouth === character.traits.mouth
    ) {
      entry.discovered = true;
    }
  });
}

function renderDex() {
  const ul = document.getElementById("dexList");
  ul.innerHTML = "";

  DEX.forEach(entry => {
    const li = document.createElement("li");

    if (entry.discovered) {
      // ë°œê²¬ëœ ì¢… â†’ ìºë¦­í„° ë Œë”
      const dummy = {
        traits: {
          bodyShape: entry.bodyShape,
          eye: entry.eye,
          mouth: entry.mouth,
          color: 200,
          roundness: 50
        }
      };

      const charEl = renderCharacter(dummy);
      charEl.classList.add(entry.rarity);
      li.appendChild(charEl);
    } else {
      // â“ ë¯¸ë°œê²¬
      const unknown = document.createElement("div");
      unknown.className = "unknown";
      unknown.textContent = "???";
      li.appendChild(unknown);
    }

    ul.appendChild(li);
  });
}

/**********************
 * ê²Œì„ ë™ì‘
 **********************/
document.getElementById("meetBtn").onclick = () => {
  partner = generateRandomCharacter();
  render();
};

document.getElementById("breedBtn").onclick = () => {
  if (selectedIndexes.length === 0) {
    alert("ë¶€ëª¨ë¥¼ ì„ íƒí•´!");
    return;
  }

  const parentA = characters[selectedIndexes[0]];
  const parentB =
    selectedIndexes[1] !== undefined
      ? characters[selectedIndexes[1]]
      : partner;

  if (!parentB) {
    alert("ë‘ ë²ˆì§¸ ë¶€ëª¨ê°€ í•„ìš”í•´!");
    return;
  }

  const child = createChild(parentA, parentB);
  characters.push(child);
  registerToDex(child);

  // ğŸ”¥ ìì‹ ìë™ ì„ íƒ
  selectedIndexes = [characters.length - 1];
  partner = null;

  const similarity = calculateSimilarity(child, targetCharacter);
  
  if (similarity >= 90) {
    alert(`ğŸ‰ ëª©í‘œ ìºë¦­í„° ë‹¬ì„±! (${similarity}%)`);
  }

  render();  
};

function calculateSimilarity(a, b) {
  let score = 0;
  let total = 0;

  // numeric traits
  TRAITS.numeric.forEach(key => {
    const max = key === "color" ? 360 : 100;
    const diff = Math.abs(a.traits[key] - b.traits[key]);
    score += 1 - diff / max;
    total++;
  });

  // visual traits
  TRAITS.visual.forEach(key => {
    score += a.traits[key] === b.traits[key] ? 1 : 0;
    total++;
  });

  return Math.round((score / total) * 100);
}

let targetCharacter = generateRandomCharacter();

function renderTarget() {
  const el = document.getElementById("targetCharacter");
  el.innerHTML = "";
  el.appendChild(renderCharacter(targetCharacter));
}

function renderSimilarity() {
  const el = document.getElementById("similarity");

  if (selectedIndexes.length === 0) {
    el.textContent = "-";
    return;
  }

  const current = characters[selectedIndexes[0]];
  const value = calculateSimilarity(current, targetCharacter);
  el.textContent = value + "%";

}
/**********************
 * ì´ˆê¸°í™”
 **********************/
 const first = generateRandomCharacter();
 characters.push(first);
 registerToDex(first);
 selectedIndexes = [0];
 render();
</script>

</body>
</html>
